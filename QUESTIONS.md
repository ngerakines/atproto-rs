# Questions

This is me just trying to figure stuff out.

# Handle Exists

A handle may exist, but it must support some set of resolution methods.

For example, `nick.cauda.cloud` would exist at `https://nick.cauda.cloud/`. The DID would be resolved through an XRPC request (not `.well-known/did.json`) and would reference the PDS serving the handle.

# PDS Exists

In this scenario, a PDS exists at `https://cauda.cloud`.

The PDS will have one more more keys that it uses. At least one of these keys is provided for public key verification of signatures. Some of these keys may be "offline" keys for recovery purposes.

Implications:

* The server should support multiple signing keys
* The server should support requests to `GET /.well-known/jwks.json`

# User Exists On PDS

In this scenario, a PDS exists at `https://cauda.cloud`.

A user exists as `https://nick.cauda.cloud`.

The PDS is the first home for the user and the user did is generated by the PDS as `at://did:plc:nkr2hgvpx6ea6mwz1r90jg3h`.

Note: This command was used: `tr -dc a-z0-9 </dev/urandom | head -c 24 ; echo ''`

The following identifiers are all valid for the user:

* `nick.cauda.cloud`
* `at://nick.cauda.cloud`
* `https://nick.cauda.cloud`
* `at://did:plc:nkr2hgvpx6ea6mwz1r90jg3h`

The user can be resolved by making requests to the PDS:

* `GET https://X/xrpc/com.atproto.handle.resolve?handle=Y`
  * Where X is one of `cauda.cloud` or `nick.cauda.cloud`
  * Where Y is one of
    * `nick`
    * `nick.cauda.cloud`
    * `did:plc:nkr2hgvpx6ea6mwz1r90jg3h`

With the following python script:

```python
from multibase import encode, decode
from ecdsa import SigningKey, VerifyingKey, SECP256k1

if __name__ == "__main__":
    sk = SigningKey.generate(curve=SECP256k1)
    print("private={key}".format(key=encode("base58btc", sk.to_string()).decode("utf-8")))
    vk = sk.verifying_key
    signature = sk.sign(b"message")
    encoded_verifying_key = encode("base58btc", vk.to_string())
    print("public={key}".format(key=(encoded_verifying_key.decode("utf-8"))))
    new_vk = VerifyingKey.from_string(decode(encoded_verifying_key), curve=SECP256k1)
    assert new_vk.verify(signature, b"message")
```

Running that producing the ouput:

```
private=zA9YZhbzUXSZWpFK11QEpa7HRxnGjvHqDJRhYpDX5iGi1
public=z2yPtDdRZ79K9Tp6WtCxkhhME4QVdnMXtzY9hvaVApAgtbcpBDK8X6P5dEPchkZyTkyjNmyJdMSZvmqViXRzfvk3H
```

The following DID would exist for that handle:

```
{
  '@context': [
    'https://www.w3.org/ns/did/v1',
    'https://w3id.org/security/suites/ecdsa-2019/v1'
  ],
  id: 'did:plc:nkr2hgvpx6ea6mwz1r90jg3h',
  alsoKnownAs: [],
  verificationMethod: [
    {
      id: 'did:plc:nkr2hgvpx6ea6mwz1r90jg3h#signingKey',
      type: 'EcdsaSecp256r1VerificationKey2019',
      controller: 'did:plc:nkr2hgvpx6ea6mwz1r90jg3h',
      publicKeyMultibase: 'z4avJnZDnCJVZh9mNGT59LNLYp3yuVxFHe7RjmZpRWBAgkH3dHjGuUX3utaVnUpX9reeFEcumjr9cW7Fiw9VfMmZH'
    },
    {
      id: 'did:plc:nkr2hgvpx6ea6mwz1r90jg3h#recoveryKey',
      type: 'EcdsaSecp256r1VerificationKey2019',
      controller: 'did:plc:nkr2hgvpx6ea6mwz1r90jg3h',
      publicKeyMultibase: 'z2yPtDdRZ79K9Tp6WtCxkhhME4QVdnMXtzY9hvaVApAgtbcpBDK8X6P5dEPchkZyTkyjNmyJdMSZvmqViXRzfvk3H'
    }
  ],
  assertionMethod: [ 'did:plc:nkr2hgvpx6ea6mwz1r90jg3h#signingKey' ],
  capabilityInvocation: [ 'did:plc:nkr2hgvpx6ea6mwz1r90jg3h#signingKey' ],
  capabilityDelegation: [ 'did:plc:nkr2hgvpx6ea6mwz1r90jg3h#signingKey' ],
  service: [
    {
      id: 'did:plc:nkr2hgvpx6ea6mwz1r90jg3h#atpPds',
      type: 'AtpPersonalDataServer',
      serviceEndpoint: 'https://cauda.cloud'
    }
  ]
}
```

Upon registration, the PDS would generate `did:plc:nkr2hgvpx6ea6mwz1r90jg3h#signingKey` (private key `zErU6WGWMrrMHXGajd8RJ2476Z7pQr2prHgJS9vTpu2gF`), but user would provide `did:plc:nkr2hgvpx6ea6mwz1r90jg3h#recoveryKey` (`zA9YZhbzUXSZWpFK11QEpa7HRxnGjvHqDJRhYpDX5iGi1`) as a means to recover their content and migrate should they need to.
